import { NextRequest, NextResponse } from 'next/server';
import { writeFile } from 'fs/promises';
import path from 'path';
import Replicate from 'replicate';

/**
 * Build a prompt for the Replicate model.
 */
function buildPrompt(title: string, tone?: string): string {
  const tonePart = tone ? `in a ${tone} style, ` : '';
  return [
    `A visually striking YouTube thumbnail in 16:9 aspect ratio,`,
    tonePart,
    `featuring bold, expressive facial emotions,`,
    `with a bright, colorful, high-contrast background,`,
    `no text overlay on the image,`,
    `inspired by the video idea: "${title}".`
  ].join(' ');
}

/**
 * Validate and parse the incoming request body.
 */
async function parseAndValidateBody(req: NextRequest): Promise<{ title: string; tone?: string }> {
  let body: unknown;
  try {
    body = await req.json();
  } catch {
    throw NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
  }
  if (!body || typeof body !== 'object') {
    throw NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
  }
  const maybe = body as { title?: unknown; tone?: unknown };
  const title = maybe.title;
  const tone = maybe.tone;
  if (!title || typeof title !== 'string' || !title.trim()) {
    throw NextResponse.json({ error: 'Missing or invalid "title" (required string)' }, { status: 400 });
  }
  if (tone && typeof tone !== 'string') {
    throw NextResponse.json({ error: 'Invalid "tone" (must be a string if provided)' }, { status: 400 });
  }
  return { title: title.trim(), tone: tone ? (tone as string).trim() : undefined };
}

/**
 * POST /api/generate
 * Generates a YouTube thumbnail using Replicate AI (flux-schnell model)
 * Attempts to write the image to disk (works locally, not on Vercel/serverless).
 */
export async function POST(req: NextRequest) {
  try {
    // Parse and validate the request body
    const { title, tone } = await parseAndValidateBody(req);

    // Build the prompt
    const prompt = buildPrompt(title, tone);

    // Ensure the Replicate API token is set
    const replicateApiToken = process.env.REPLICATE_API_TOKEN;
    if (!replicateApiToken) {
      return NextResponse.json({ error: 'Replicate API token not configured' }, { status: 500 });
    }

    // Initialize Replicate client
    const replicate = new Replicate({ auth: replicateApiToken });

    // Call the Replicate model
    let output: unknown;
    try {
      output = await replicate.run('black-forest-labs/flux-schnell', {
        input: {
          prompt,
          aspect_ratio: '16:9',
          num_outputs: 1,
          num_inference_steps: 4,
          go_fast: true,
          output_format: 'webp',
          output_quality: 80,
        },
      });
    } catch (modelErr: unknown) {
      if (modelErr instanceof Error) {
        console.error('Replicate model error:', modelErr.message, modelErr.stack);
        return NextResponse.json({ error: 'Failed to generate image from Replicate', details: modelErr.message }, { status: 502 });
      }
      console.error('Replicate model error:', modelErr);
      return NextResponse.json({ error: 'Failed to generate image from Replicate', details: String(modelErr) }, { status: 502 });
    }

    // Validate output: should be a non-empty array of image URLs or buffers
    if (!output || !Array.isArray(output) || output.length === 0) {
      console.error('Replicate returned empty or invalid output:', output);
      return NextResponse.json({ error: 'No images generated by model' }, { status: 502 });
    }

    // Try to write files to disk (works locally, not on Vercel/serverless)
    const filePaths: string[] = [];
    const failedToWrite: boolean[] = [];
    for (const [index, item] of Object.entries(output)) {
      try {
        // If item is a URL, fetch the image data
        let buffer: Buffer;
        if (typeof item === 'string' && item.startsWith('http')) {
          const res = await fetch(item);
          buffer = Buffer.from(await res.arrayBuffer());
        } else if (item instanceof Buffer) {
          buffer = item;
        } else {
          throw new Error('Unknown image format from Replicate');
        }
        const fileName = `output_${index}.webp`;
        const filePath = path.join(process.cwd(), 'public', fileName);
        await writeFile(filePath, buffer);
        filePaths.push(`/public/${fileName}`);
        failedToWrite.push(false);
      } catch (err) {
        // If writing fails (e.g., on Vercel), just return the Replicate URL
        filePaths.push(typeof item === 'string' ? item : '');
        failedToWrite.push(true);
      }
    }

    // If all writes failed, warn about serverless limitations
    if (failedToWrite.every(Boolean)) {
      return NextResponse.json({
        warning: 'File writing is not supported on serverless/Vercel. Returning Replicate URLs instead.',
        images: filePaths
      }, { status: 200 });
    }

    // Return the file paths (or Replicate URLs if writing failed)
    return NextResponse.json({ images: filePaths }, { status: 200 });
  } catch (err: unknown) {
    if (err instanceof NextResponse) {
      return err;
    }
    if (err instanceof Error) {
      console.error('API route error:', err.message, err.stack);
    } else {
      console.error('API route error:', err);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

async function generateThumbnail(title: string, tone?: string) {
  const res = await fetch('/api/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title, tone }),
  });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'Failed to generate');
  return data.images; // array of file paths or URLs
} 