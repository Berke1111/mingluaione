import { NextRequest, NextResponse } from 'next/server';
import Replicate from 'replicate';

/**
 * Build a prompt for the Replicate model.
 */
function buildPrompt(title: string, tone?: string): string {
  const tonePart = tone ? `in a ${tone} style, ` : '';
  return [
    `A visually striking YouTube thumbnail in 16:9 aspect ratio,`,
    tonePart,
    `featuring bold, expressive facial emotions,`,
    `with a bright, colorful, high-contrast background,`,
    `no text overlay on the image,`,
    `inspired by the video idea: "${title}".`
  ].join(' ');
}

/**
 * Validate and parse the incoming request body.
 */
async function parseAndValidateBody(req: NextRequest): Promise<{ title: string; tone?: string }> {
  let body: any;
  try {
    body = await req.json();
  } catch {
    throw NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
  }
  const { title, tone } = body || {};
  if (!title || typeof title !== 'string' || !title.trim()) {
    throw NextResponse.json({ error: 'Missing or invalid \"title\" (required string)' }, { status: 400 });
  }
  if (tone && typeof tone !== 'string') {
    throw NextResponse.json({ error: 'Invalid \"tone\" (must be a string if provided)' }, { status: 400 });
  }
  return { title: title.trim(), tone: tone?.trim() };
}

/**
 * POST /api/generate
 * Generates a YouTube thumbnail using Replicate AI (flux-schnell model)
 * Attempts to write the image to disk (works locally, not on Vercel/serverless).
 */
export async function POST(req: NextRequest) {
  try {
    // Parse and validate the request body
    const { title, tone } = await parseAndValidateBody(req);

    // Build the prompt
    const prompt = buildPrompt(title, tone);

    // Ensure the Replicate API token is set
    const replicateApiToken = process.env.REPLICATE_API_TOKEN;
    if (!replicateApiToken) {
      return NextResponse.json({ error: 'Replicate API token not configured' }, { status: 500 });
    }

    // Initialize Replicate client
    const replicate = new Replicate({ auth: replicateApiToken });

    // Call the Replicate model
    let output: any;
    try {
      output = await replicate.run('black-forest-labs/flux-schnell', {
        input: {
          prompt,
          aspect_ratio: '16:9',
          num_outputs: 1,
          num_inference_steps: 4,
          go_fast: true,
          output_format: 'webp',
          output_quality: 80,
        },
      });
    } catch (modelErr: any) {
      console.error('Replicate model error:', modelErr);
      return NextResponse.json({ error: 'Failed to generate image from Replicate', details: modelErr?.message || modelErr }, { status: 502 });
    }

    // Validate output: should be a non-empty array of image URLs or buffers
    if (!output || !Array.isArray(output) || output.length === 0) {
      console.error('Replicate returned empty or invalid output:', output);
      return NextResponse.json({ error: 'No images generated by model' }, { status: 502 });
    }

    // Return Replicate URLs directly (no file writing)
    const imageUrls = output.map((item: any) => (typeof item === 'string' ? item : ''));
    return NextResponse.json({ images: imageUrls }, { status: 200 });
  } catch (err: any) {
    if (err instanceof NextResponse) {
      return err;
    }
    console.error('API route error:', err);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

async function generateThumbnail(title: string, tone?: string) {
  const res = await fetch('/api/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title, tone }),
  });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'Failed to generate');
  return data.images; // array of file paths or URLs
} 